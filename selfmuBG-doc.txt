
# The following is a sequence of functions to define the function
# EBeta which takes a prime e and a self-Mullineux partitions and
# returns the BG-partition associated under the correspondence
# defined from the Mullineux symbol.

DiagramPartition:=function(mu)
# Takes a partition mu and returns the set of nodes that form the Young 
# diagram of mu.


Rim:=function(mu)
# Takes a partition mu and returns the set of nodes (i,j) of the rim of mu

OrgRim:=function(mu)
# Takes a partition mu and returns a list of the nodes of the rim of the diagram of mu, organized from "north-east" to "south-west" of the Young diagram.



HookLength:=function(la,i,j)
# Takes a partition la and a node (i,j) in the Young diagram of la and returns the hook-length of the (i,j)-th hook

PartitionDiag:=function(nodes)
# Takes a set of nodes forming a Young diagram and returns the associated partition.


DiagBoxRim:=function(mu)
# Takes a self-conjugate partition mu an returns i the only diagonal where (i,i) is the only diagonal node in the rim of mu.


PRim1:=function(e,mu)
# Set U of the p-rim* of mu.


PRim2:=function(l,e)
# Fix the middle segment



PRim3:=function(e,mu)
# The subset U of the p-rim*


PRim4:=function(e,mu)
# The reflection of subset U of the p-rim*


PRim5:=function(e,mu)
# p-rim* for self-conjugate mu



ERim:=function(e,mu)
#Takes an odd prime e and a self-conjugate partition mu and returns [mu^(1)*,e-rim*] where e-rim is the e-rim* of a self-conjugate partition and mu^(1)* is the partition obtained from mu after deleting the e-rim*.

AutoSymb:=function(e,mu)
# takes a prime e and a self-conjugate partition mu and returns the first line of the p-BG-symbol (first line) for mu


EBGsymb:=function(p,mu)
# Takes a prime p and a self-conjugate partition mu and returns the p-BG-symbol mu


EBetaInverse:=function(e,la)
# Takes an odd prime e, and a e-BG-partition la and returns the e-self-Mullineux partition corresponding to la under the bijection defined by the bg-symbol.


DurfeeNumber:=function(mu)
# takes a partition and returns its durfee number

EBGPartitions:=function(p,n)
# Takes an odd prime p and an integer n and returns the list of pBG-partitions of n




EBetaSymbol:=function(e,symb)
# Takes a prime e and the Mullineux symbol symb (list of rows) of a e-self-Mullineux partition and returns the associated e-BG-partition.



EBeta:=function(e,mu)
# Takes a prime e and a e-self-Mullineux mu and returns the e-BG-partition partition corresponding to mu under the bijection defined by the bg-symbol.


#######################################################################
#
# The following is a list of functions to test which blocks of the
# symmetric group have compatible completely admissible transversals.
# 

# Takes an integer e<n and n and returns all partitions in the block
# of S_n corresponding to the core core.
BlockPartitionsCore:=function(e,n,core)


# Same as BlockPartitionsCore, but with the weight w.
BlockPartitionsWeightCore:=function(e,w,core)

# Returns all e-regular partitions on a block with a given core
BlockPartitionsCoreERegulars:=function(e,n,core)


# Same but with weight 
BlockPartitionsWeightCoreERegulars:=function(e,w,core)

# Self-Mullineux partitions in the e-block with weight
BlockPartitionsWeightCoreERegularsSM:=function(e,w,core)


# returns all e-regular partitions of integers less than n
# of e weight w
EWeightWPart:=function(e,w,n)


# Returns the list of e-cores of rank up to m
ListECores:=function(e,m)

# Returns the list of self-conjugate e-cores of rank up to m
ListECoresSC:=function(e,m)



#list of all the e-cores of partitions of n
ECoresList:=function(e,n)


#list of all partitions of n organised by blocks (corresponding to e-cores)
PartitionsByBlocks:=function(e,n)


# Returns the list formed by partitions with e-core core or core'
# and e-weight w
SSet:=function(e,w,core)


# Returns the list of e-regular partitions in SSet(e,w,core)
SSetReg:=function(e,w,core)


AdmTransversals:=function(e,w,core)
# Returns a list of all the possible admissible
# transversals for the e-block of weight w of the
# block corresponding to the core core.


Test1AdmTransversals:=function(e,m)
# For testing if the above function gives in fact
# all admissible transversals we have to look for an
# example where there exists at least two adm. tr.
# For this, the following function looks for a block
# where this happens.
# The test function will look for e-blocks
# where the rank of the e-blocks goes up to m.

# Returns a list of completely admissible transversals
# of the e-core of weight w and core core
ComplAdmTransversals:=function(e,w,core)

# tests if there are (and how many) completely admissible
# transversals for e-cores up to rank m.
Test1CompltAdmTransversals:=function(e,m)

# tests how many completely admissible transversals
# for every e-core with e every odd up to the odd k
# and every e-core with rank up to m
#tested see file  Test1Proposition7Weight2(11,15)
Test1Proposition7Weight2:=function(k,m)


# Returns a list of all the possible compatible
# transversals for the e-block of weight w of the
# block corresponding to the core core.
CompTransversals:=function(e,w,core)




 